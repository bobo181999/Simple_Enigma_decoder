# Simple_Enigma_decoder
Project Description : 
Simple Enigma Engine

The real Enigma had from 3 to 7 rotors.  On each rotor the letters of the alphabet were distributed, as well as some numbers and punctuation.  These combinations led up to well over 3 million permutations.  In modeling the Enigma's logic, this simplified model has only two rotors, containing the letters a-z and a ' ' character on each rotor.  

Using the idea of the Caesar Cypher, the Simple Enigma Engine only has 2 rotors.  The first rotor set the initial 'offset' from the actual letter.  For example, suppose the initial letter to encrypt is the letter 'a', and the offset is 3:  'a' (ascii 97) + offset(3) = ascii(100) or letter 'd'.  The second rotor also has a initial 'offset' from the actual letter.  For example, suppose the initial offset is 10:  'a' (ascii 97) + offset(10) = ascii(107) or letter 'k'.  

To encrypt the first letter of the text to encrypt, add the rotor1 offset + the rotor2 offset (i.e. offset(3)+offset(10) = offset(13) from 'a' equals ascii(110) or letter 'n'.  

To encrypt the next letter of the text to encrypt, increment rotor2 offset by 1 (i.e. increment offset(10) to offset(11)), add rotor1.offset to rotor2.offset.  For example, suppose the next letter to encrypt is again an 'a':  'a' (ascii 97) + rotor1.offset(3) + rotor2.offset(11) = ascii(111) or letter 'o'.

So the first two letters of the 'aa' script would be encrypted with 'no'.  On each successive letter in the text, increment rotor2 by one.  On the 'real' Enigma machine, when rotor2 ran one complete rotation, rotor1 would increment by 1.  However, for this simple Enigma Engine, rotor1 remains stationary while rotor2 may have multiple rotations.

With the Caesar Cypher, character frequency analysis could be used determine the offset of the most frequent character like 'e' or 't' in the English language.  Character frequency analysis is useless to determine the character frequencies, as the letter offsets are incremented for rotor2 on each sub-rotation, as illustrated by 'aa' yielding 'no'.
  
For the analysis, the rotor1 and rotor2 initial settings must be determined.  One could simply go through all the permutations of rotor1 and rotor2 until the correct settings of the rotors are determined.  However, build in some 'AI' (artificial intelligence) into your decryption.  

Assume there will be common words like 'an','to','and','for','the' and so on in the text.  Select one letter, with the guess it is an 'a'.  Do some rotation analysis for rotor1 and rotor2 and 'decrypt' the next letter.  If it comes out to be an 'n', for example, you may have the word 'an'.  By inspecting the next letter with your calculated rotations, the next letter could be a ' ' or a 'd'.  If either of these letters is found, you have either an 'an' or 'and', and you can apply your calculated offsets to the text.

If your premise or calculated rotor offsets are incorrect, either change or initial letter guess or rotor analysis, and repeat.  

Here is a text phrase generated by the Simple Enigma Engine:
"tynirtgjdtrnudnrvavnaayshfbvptbggnlbmmobtqwdyjcxkr"

The text contains most of the letters in the alphabet as well as common English words as mentioned above.  The goal is to see how easy or difficult it is to find the rotors settings that produce the correct words.
